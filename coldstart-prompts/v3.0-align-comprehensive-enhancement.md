# COLDSTART PROMPT: AgentReady v3.0 - Comprehensive Align Enhancement

**Context**: You are implementing v3.0 of the AgentReady align subcommand. The basic infrastructure exists (CLI, BaseFixer, FixerService, Fix models), but you need to expand from 3 fixers to 15+ fixers with AI capabilities.

**Current Repository State** (v2.8.1):
- Repository: `agentready` - Repository quality assessment tool
- Branch: `main` (start from here)
- Existing align implementation: `src/agentready/cli/align.py` (195 lines, working)
- Existing fixers: CLAUDEmdFixer, GitignoreFixer, PrecommitHooksFixer
- Infrastructure: Complete (BaseFixer, FixerService, Fix models all working)

---

## Your Mission

Expand the `agentready align` command to provide comprehensive automated remediation across 15+ AgentReady attributes, including AI-powered fixes for complex code quality issues.

**Scope**:
1. **Add 12 template-based fixers** (Phase 1 - Week 1-2)
2. **Add AI fixer infrastructure** (Phase 2 - Week 3)
3. **Add 3 AI-powered fixers** (Phase 2 - Week 4)
4. **Add GitHub PR integration** (Phase 3 - Week 5)
5. **Polish and document** (Phase 4 - Week 6)

**Key Constraint**: Build on existing architecture, don't rebuild. The core align.py, BaseFixer, and FixerService are solid.

---

## Phase 1: Template-Based Fixers (Priority: P0)

### Fixers to Implement

1. **README Structure Fixer** (`src/agentready/fixers/documentation.py`)
   - Attribute ID: `readme_structure`
   - Action: Add missing sections to README.md (Installation, Usage, Development, Contributing)
   - Implementation: Use Jinja2 template to scaffold sections
   - File: Extend existing `documentation.py`
   - Test: `tests/unit/fixers/test_readme_fixer.py`

2. **Standard Layout Fixer** (`src/agentready/fixers/structure.py` - NEW)
   - Attribute ID: `standard_layout`
   - Action: Create missing directories (src/, tests/, docs/) with .gitkeep
   - Implementation: Simple Path.mkdir() operations
   - File: New fixer module
   - Test: `tests/unit/fixers/test_structure_fixers.py`

3. **Lock Files Fixer** (`src/agentready/fixers/structure.py`)
   - Attribute ID: `lock_files`
   - Action: Generate lock files by running package managers
   - Implementation: CommandFix to run `npm install`, `pip freeze > requirements.txt`, `go mod tidy`
   - Language detection: Use repository.languages
   - Test: Mock subprocess calls

4. **Conventional Commits Fixer** (`src/agentready/fixers/integration.py` - NEW)
   - Attribute ID: `conventional_commits`
   - Action: Create .commitlintrc.json + package.json scripts
   - Implementation: Template-based FileCreationFix
   - File: New integration fixer module
   - Test: Validate generated config

5. **Issue/PR Templates Fixer** (`src/agentready/fixers/integration.py`)
   - Attribute ID: `issue_pr_templates`
   - Action: Create .github/ISSUE_TEMPLATE/ and PULL_REQUEST_TEMPLATE.md
   - Implementation: Copy templates from `src/agentready/templates/fixers/`
   - File: Multiple FileCreationFix operations
   - Test: Validate all templates created

6. **CI/CD Pipeline Fixer** (`src/agentready/fixers/integration.py`)
   - Attribute ID: `cicd_pipeline`
   - Action: Create GitHub Actions workflows (tests.yml, security.yml)
   - Implementation: Language-specific workflow templates
   - Templates: `src/agentready/templates/fixers/workflows/`
   - Test: Validate workflow YAML syntax

7. **One Command Setup Fixer** (`src/agentready/fixers/structure.py`)
   - Attribute ID: `one_command_setup`
   - Action: Create setup script (setup.sh for Unix, setup.bat for Windows)
   - Implementation: Analyze dependencies, generate script
   - File: Shell script with install commands
   - Test: Validate script syntax

8. **OpenAPI Spec Fixer** (Stub - `src/agentready/fixers/integration.py`)
   - Attribute ID: `openapi_specs`
   - Action: Return guidance to manually create OpenAPI spec
   - Implementation: Provide template and documentation link
   - Note: Full automation requires AI, stub for now
   - Test: Validate guidance message

### Implementation Pattern

```python
# Example: README Structure Fixer
class READMEStructureFixer(BaseFixer):
    """Add missing sections to README.md."""

    @property
    def attribute_id(self) -> str:
        return "readme_structure"

    def can_fix(self, finding: Finding) -> bool:
        # Can fix if README exists but is incomplete
        return finding.status == "fail" and "missing sections" in finding.evidence

    def generate_fix(self, repository: Repository, finding: Finding) -> Optional[Fix]:
        readme_path = repository.path / "README.md"

        if not readme_path.exists():
            return None  # Can't fix non-existent README

        # Determine missing sections from finding.evidence
        missing_sections = self._parse_missing_sections(finding.evidence)

        # Generate section content
        additions = []
        for section in missing_sections:
            template = self._get_section_template(section)
            content = template.render(repository=repository)
            additions.append(f"\n## {section}\n\n{content}\n")

        return FileModificationFix(
            attribute_id=self.attribute_id,
            description=f"Add {len(missing_sections)} missing sections to README.md",
            points_gained=self.estimate_score_improvement(finding),
            file_path=Path("README.md"),
            additions=additions,
            repository_path=repository.path,
            append=True
        )
```

### Templates to Create

Create Jinja2 templates in `src/agentready/templates/fixers/`:

1. `README_sections.md.j2` - Template for README sections
2. `workflows/tests-python.yml.j2` - Python test workflow
3. `workflows/tests-javascript.yml.j2` - JavaScript test workflow
4. `workflows/security.yml.j2` - Security scanning workflow
5. `issue_templates/bug_report.md` - Bug report template
6. `issue_templates/feature_request.md` - Feature request template
7. `pull_request_template.md` - PR template
8. `.commitlintrc.json.j2` - Commitlint config

### Testing Requirements

Each fixer must have:
1. Unit test with mocked repository
2. Test for `can_fix()` logic
3. Test for `generate_fix()` success path
4. Test for `generate_fix()` failure paths
5. Test for dry-run mode
6. Test for estimated points calculation

Example test structure:
```python
def test_readme_structure_fixer_can_fix():
    """Test that fixer can identify fixable READMEs."""
    fixer = READMEStructureFixer()
    finding = create_mock_finding(
        attribute_id="readme_structure",
        status="fail",
        evidence="Missing sections: Installation, Usage"
    )
    assert fixer.can_fix(finding) is True

def test_readme_structure_fixer_generate_fix(tmp_path):
    """Test fix generation."""
    # Create repository with incomplete README
    readme = tmp_path / "README.md"
    readme.write_text("# Project\n\nSome description.")

    repo = Repository(path=tmp_path, languages=["Python"], metadata={})
    finding = create_mock_finding(...)

    fixer = READMEStructureFixer()
    fix = fixer.generate_fix(repo, finding)

    assert fix is not None
    assert isinstance(fix, FileModificationFix)
    assert "Installation" in "\n".join(fix.additions)
```

### Phase 1 Acceptance Criteria

- [ ] 8 new fixers implemented
- [ ] All fixers registered in FixerService
- [ ] All templates created and validated
- [ ] Test coverage >80% for fixer code
- [ ] `agentready align .` can fix 11/25 attributes
- [ ] Dry-run mode works for all fixers
- [ ] Documentation updated in `docs/user-guide.md`

---

## Phase 2: AI-Powered Fixers (Priority: P1)

### AI Infrastructure

1. **Create AIFixer Base Class** (`src/agentready/fixers/ai_fixer.py`)

```python
from abc import ABC
from anthropic import Anthropic
from .base import BaseFixer

class AIFixer(BaseFixer, ABC):
    """Base class for LLM-powered fixers.

    Provides:
    - LLM client management (Anthropic API)
    - Code sampling from repository
    - Safe code modification
    - Validation before applying changes
    - Cost tracking
    """

    def __init__(self, api_key: Optional[str] = None):
        """Initialize with API key from env or parameter."""
        self.api_key = api_key or os.getenv("ANTHROPIC_API_KEY")
        if self.api_key:
            self.client = Anthropic(api_key=self.api_key)
        else:
            self.client = None

    def is_enabled(self) -> bool:
        """Check if AI fixes are enabled (API key present)."""
        return self.client is not None

    def sample_code(self, repository: Repository, max_files: int = 10) -> List[Dict]:
        """Sample relevant code files from repository.

        Returns list of {path, content, language} dicts.
        """
        # Use repository.languages to filter
        # Read up to max_files relevant files
        # Return code samples for LLM context

    def generate_fix_with_llm(
        self,
        repository: Repository,
        finding: Finding,
        prompt_template: str,
        max_tokens: int = 4096
    ) -> Optional[Fix]:
        """Generate fix using Claude API.

        Args:
            repository: Repository to fix
            finding: Failing finding
            prompt_template: Prompt with {placeholders}
            max_tokens: Max tokens for response

        Returns:
            Fix if successful, None if failed or API unavailable
        """
        if not self.is_enabled():
            return None

        # Build prompt from template
        code_samples = self.sample_code(repository)
        prompt = prompt_template.format(
            repository=repository,
            finding=finding,
            code_samples=code_samples
        )

        try:
            # Call LLM
            response = self.client.messages.create(
                model="claude-sonnet-4-5-20250929",
                max_tokens=max_tokens,
                messages=[{"role": "user", "content": prompt}]
            )

            # Extract code from response
            generated_code = self._extract_code_blocks(response.content)

            # Validate generated code
            if self.validate_generated_code(generated_code, repository):
                return self.create_fix_from_code(generated_code, finding)

        except Exception as e:
            # Log error, return None (graceful degradation)
            print(f"AI fix generation failed: {e}")

        return None

    def validate_generated_code(self, code: str, repository: Repository) -> bool:
        """Validate AI-generated code before applying.

        Checks:
        - Syntax validity (compile/parse)
        - No malicious patterns
        - File paths within repository
        - Reasonable code size
        """
        # Implement validation logic

    def estimate_cost(self, prompt: str, max_tokens: int) -> float:
        """Estimate API cost in USD."""
        # Claude Sonnet 4.5 pricing:
        # Input: $3/million tokens
        # Output: $15/million tokens
        input_tokens = len(prompt) / 4  # Rough estimate
        output_tokens = max_tokens
        return (input_tokens * 3 + output_tokens * 15) / 1_000_000
```

### AI Fixers to Implement

1. **Inline Documentation Fixer** (`src/agentready/fixers/ai_powered.py`)
   - Attribute ID: `inline_documentation`
   - Action: Generate docstrings for functions missing documentation
   - Implementation:
     - Use AST to find undocumented functions
     - Sample function code
     - Generate docstring with Claude
     - Insert docstring into file
   - Validation: Parse generated docstring, ensure proper format
   - Test: Mock LLM responses

2. **Type Annotations Fixer** (`src/agentready/fixers/ai_powered.py`)
   - Attribute ID: `type_annotations`
   - Action: Add type hints to Python functions
   - Implementation:
     - Use AST to find unannotated functions
     - Analyze function usage
     - Generate type hints with Claude
     - Apply using AST manipulation
   - Validation: Run mypy on result
   - Test: Mock LLM, validate mypy compatibility

3. **Test Coverage Fixer** (`src/agentready/fixers/ai_powered.py`)
   - Attribute ID: `test_coverage`
   - Action: Generate test scaffolding for untested files
   - Implementation:
     - Identify files with <80% coverage
     - Sample file to test
     - Generate pytest test file with Claude
     - Create test file
   - Validation: Run pytest --collect-only to validate syntax
   - Test: Mock LLM, verify test structure

### Prompt Templates

Create prompts in `src/agentready/fixers/prompts/`:

```python
# prompts/inline_documentation.txt
"""You are helping add documentation to code.

Repository: {repository.path}
Language: {repository.languages[0]}

Function missing documentation:
```{language}
{function_code}
```

Generate a comprehensive docstring in {language} style.
- For Python: Use Google-style docstrings
- For JavaScript: Use JSDoc
- For Go: Use standard Go comments

Return ONLY the docstring text, no code fences.
"""

# prompts/type_annotations.txt
"""You are adding type annotations to improve code quality.

Function without type hints:
```python
{function_code}
```

Usage examples:
{usage_examples}

Add type hints to this function. Return the complete function with type hints added.
Use standard Python type hints (typing module).
"""
```

### Phase 2 Acceptance Criteria

- [ ] AIFixer base class implemented
- [ ] 3 AI fixers working (inline docs, types, tests)
- [ ] Cost estimation before execution
- [ ] Graceful fallback if API key missing
- [ ] All AI-generated code validated
- [ ] Test coverage >80% (with mocked LLM)
- [ ] Cost per fix <$0.10
- [ ] Documentation for AI fix opt-in

---

## Phase 3: GitHub Integration & Safety (Priority: P1)

### GitHub PR Creation

1. **Add --create-pr flag** (`src/agentready/cli/align.py`)

```python
@click.option("--create-pr", is_flag=True, help="Create GitHub PR with fixes")
def align(repository, dry_run, create_pr, interactive, attributes):
    # ... existing assessment logic ...

    if create_pr:
        # Ensure clean working directory
        if has_uncommitted_changes(repo_path):
            click.echo("Error: Uncommitted changes detected. Commit or stash first.")
            sys.exit(1)

        # Create feature branch
        branch_name = f"agentready-align-{datetime.now().strftime('%Y%m%d-%H%M%S')}"
        run_git(["checkout", "-b", branch_name], cwd=repo_path)

        # Apply fixes
        results = fixer_service.apply_fixes(fixes_to_apply, dry_run=False)

        # Commit changes
        run_git(["add", "."], cwd=repo_path)
        commit_msg = generate_commit_message(assessment, fix_plan)
        run_git(["commit", "-m", commit_msg], cwd=repo_path)

        # Push branch
        run_git(["push", "-u", "origin", branch_name], cwd=repo_path)

        # Create PR using gh CLI
        pr_body = generate_pr_description(assessment, fix_plan, results)
        pr_url = create_github_pr(
            branch=branch_name,
            title=f"Improve AgentReady score from {assessment.certification_level} to {fix_plan.projected_level}",
            body=pr_body
        )

        click.echo(f"\nâœ… Created PR: {pr_url}")
```

2. **PR Description Template**

```markdown
## AgentReady Automated Fixes

**Score Improvement**: {current_score:.1f} â†’ {projected_score:.1f} ({delta:+.1f} points)
**Certification**: {current_level} â†’ {projected_level}

### Fixes Applied

{fix_list}

### Before/After Comparison

| Metric | Before | After |
|--------|--------|-------|
| Overall Score | {current_score}/100 | {projected_score}/100 |
| Attributes Fixed | {fixed_count} | - |
| Certification Level | {current_level} | {projected_level} |

### Test Plan

- [ ] Verify all files created correctly
- [ ] Run tests: `{test_command}`
- [ ] Check GitHub Actions workflows
- [ ] Validate new configurations work

---

ðŸ¤– Generated automatically with [AgentReady](https://github.com/ambient-code/agentready)
```

### Safety Manager

1. **Create FixSafetyManager** (`src/agentready/fixers/safety.py`)

```python
class FixSafetyManager:
    """Manages backups and rollbacks for fixes."""

    def __init__(self, repository_path: Path):
        self.repository_path = repository_path
        self.backup_id = None

    def create_backup(self) -> str:
        """Create git stash backup.

        Returns:
            Backup ID for rollback
        """
        self.backup_id = f"agentready-backup-{int(time.time())}"

        # Git stash with untracked files
        subprocess.run(
            ["git", "stash", "push", "-u", "-m", self.backup_id],
            cwd=self.repository_path,
            check=True
        )

        return self.backup_id

    def rollback(self, backup_id: Optional[str] = None):
        """Rollback to backup."""
        backup_id = backup_id or self.backup_id

        # Find stash by message
        result = subprocess.run(
            ["git", "stash", "list"],
            cwd=self.repository_path,
            capture_output=True,
            text=True
        )

        # Find matching stash
        for line in result.stdout.splitlines():
            if backup_id in line:
                stash_ref = line.split(":")[0]  # e.g., "stash@{0}"
                subprocess.run(
                    ["git", "stash", "pop", stash_ref],
                    cwd=self.repository_path,
                    check=True
                )
                return

        raise ValueError(f"Backup {backup_id} not found")
```

2. **Integrate into align command**

```python
def align(...):
    # ... existing code ...

    # Create backup before applying fixes
    safety_manager = FixSafetyManager(repo_path)

    try:
        backup_id = safety_manager.create_backup()
        click.echo(f"Created backup: {backup_id}")

        # Apply fixes
        results = fixer_service.apply_fixes(fixes_to_apply, dry_run=False)

        if results["failed"] > 0:
            # Rollback on failure
            if click.confirm("Some fixes failed. Rollback all changes?", default=True):
                safety_manager.rollback()
                click.echo("Rolled back all changes.")
                sys.exit(1)

    except Exception as e:
        # Emergency rollback
        click.echo(f"Error: {e}")
        if click.confirm("Rollback all changes?", default=True):
            safety_manager.rollback()
        sys.exit(1)
```

### Configuration System

1. **Create Config Model** (`src/agentready/models/align_config.py`)

```python
from pydantic import BaseModel

class AlignConfig(BaseModel):
    """Configuration for align command."""

    enabled: bool = True

    # Automatic fixes (no confirmation)
    auto_fix: List[str] = [
        "claude_md_file",
        "gitignore_completeness",
        "readme_structure",
        "standard_layout",
    ]

    # Require confirmation
    confirm_before_fix: List[str] = [
        "type_annotations",
        "cyclomatic_complexity",
    ]

    # Never fix automatically
    never_fix: List[str] = []

    # AI configuration
    ai_fixes_enabled: bool = False
    ai_provider: str = "anthropic"
    ai_model: str = "claude-sonnet-4-5-20250929"
    ai_max_tokens: int = 4096
    ai_max_cost_per_fix: float = 0.10

    # GitHub configuration
    github_create_pr_by_default: bool = False
    github_pr_labels: List[str] = ["agentready", "automated-fix"]
```

2. **Load Configuration** (`src/agentready/services/config_loader.py`)

```python
def load_align_config(repository_path: Path) -> AlignConfig:
    """Load align configuration from .agentready-config.yaml."""
    config_file = repository_path / ".agentready-config.yaml"

    if config_file.exists():
        with open(config_file) as f:
            data = yaml.safe_load(f)
            return AlignConfig(**data.get("align", {}))

    return AlignConfig()  # Defaults
```

### Phase 3 Acceptance Criteria

- [ ] --create-pr flag working
- [ ] PRs created with proper description
- [ ] Safety manager creates backups
- [ ] Rollback functionality works
- [ ] Configuration system implemented
- [ ] Config validated on load
- [ ] Documentation updated

---

## Phase 4: Polish & Documentation (Priority: P2)

### Documentation

1. **User Guide** (`docs/user-guide.md`)

Add comprehensive section:
```markdown
## Automated Remediation with `align`

The `align` command automatically fixes failing AgentReady attributes by generating files, modifying configurations, and running package managers.

### Basic Usage

```bash
# Preview fixes (dry-run)
agentready align . --dry-run

# Apply fixes interactively
agentready align . --interactive

# Apply all fixes
agentready align .

# Create GitHub PR with fixes
agentready align . --create-pr
```

### AI-Powered Fixes

Enable AI fixes for complex attributes:

```bash
# Set API key
export ANTHROPIC_API_KEY=sk-ant-...

# Enable AI fixes
agentready align . --ai
```

AI fixes include:
- Inline documentation (docstrings)
- Type annotations
- Test coverage scaffolding

### Configuration

Create `.agentready-config.yaml`:

```yaml
align:
  auto_fix:
    - claude_md_file
    - gitignore_completeness

  ai_fixes_enabled: true
  ai_max_cost_per_fix: 0.10
```

### Safety Features

- **Automatic backup**: Git stash created before fixes
- **Rollback**: One command to undo all changes
- **Dry-run mode**: Preview changes without applying
- **Validation**: All fixes validated before application
```

2. **Developer Guide** (`docs/developer-guide.md`)

Add section on creating fixers:
```markdown
## Creating New Fixers

### Template-Based Fixer

```python
class MyFixer(BaseFixer):
    @property
    def attribute_id(self) -> str:
        return "my_attribute"

    def can_fix(self, finding: Finding) -> bool:
        return finding.status == "fail"

    def generate_fix(self, repository: Repository, finding: Finding) -> Optional[Fix]:
        return FileCreationFix(
            attribute_id=self.attribute_id,
            description="Create my file",
            points_gained=self.estimate_score_improvement(finding),
            file_path=Path("myfile.txt"),
            content="Content here",
            repository_path=repository.path
        )
```

### AI-Powered Fixer

```python
class MyAIFixer(AIFixer):
    @property
    def attribute_id(self) -> str:
        return "my_ai_attribute"

    def generate_fix(self, repository: Repository, finding: Finding) -> Optional[Fix]:
        prompt = """Generate code for {finding.attribute.name}..."""

        return self.generate_fix_with_llm(
            repository, finding, prompt, max_tokens=2048
        )
```

### Testing

```python
def test_my_fixer():
    fixer = MyFixer()
    repo = Repository(path=tmp_path, ...)
    finding = Finding(...)

    fix = fixer.generate_fix(repo, finding)
    assert fix is not None
```
```

### Performance Optimization

1. **Parallel fix generation** (optional)
2. **Cache LLM responses** for common patterns
3. **Lazy load fixers** (only initialize when needed)

### Security Audit

1. **Run security scans**: `bandit src/`
2. **Validate all subprocess calls** use shlex.split()
3. **Review AI-generated code validation**
4. **Check for injection vulnerabilities**

### Phase 4 Acceptance Criteria

- [ ] All documentation complete
- [ ] Performance <30s for typical repo
- [ ] Security scan passes
- [ ] Test coverage >85%
- [ ] v3.0 release notes written

---

## Implementation Guidelines

### Code Quality Standards

1. **Type hints**: All functions must have type hints
2. **Docstrings**: All public methods must have docstrings
3. **Tests**: >80% coverage for all new code
4. **Linting**: Pass black, isort, ruff
5. **Security**: Pass bandit scans

### Git Workflow

1. Create feature branch: `feature/v3.0-align-phase-{N}`
2. Commit frequently with conventional commits
3. Run tests before every commit
4. Create PR when phase complete
5. Squash merge to main

### Testing Requirements

Each PR must include:
- Unit tests for new code
- Integration tests for workflows
- Updated documentation
- Passing CI checks

---

## Success Criteria

**Functionality**:
- [ ] Can fix 14/25 attributes automatically
- [ ] AI fixes work with valid API key
- [ ] GitHub PR creation works
- [ ] Rollback functionality tested

**Quality**:
- [ ] Test coverage >85%
- [ ] All security scans pass
- [ ] Performance <30s typical repo
- [ ] Documentation complete

**User Experience**:
- [ ] Clear progress indicators
- [ ] Helpful error messages
- [ ] Dry-run mode works perfectly
- [ ] Configuration system intuitive

---

## Key Files to Modify

**Existing** (enhance):
- `src/agentready/cli/align.py` - Add flags, PR creation
- `src/agentready/services/fixer_service.py` - Add AI fixers
- `src/agentready/fixers/documentation.py` - Add README fixer
- `src/agentready/fixers/testing.py` - Add test coverage fixer

**New** (create):
- `src/agentready/fixers/ai_fixer.py` - AI base class
- `src/agentready/fixers/safety.py` - Safety manager
- `src/agentready/fixers/structure.py` - Layout, lock files
- `src/agentready/fixers/integration.py` - CI/CD, templates
- `src/agentready/fixers/ai_powered.py` - AI fixers
- `src/agentready/templates/fixers/` - All templates
- `tests/unit/fixers/` - Fixer tests

---

## Getting Started

1. **Read existing code**:
   - `src/agentready/cli/align.py` - Understand current flow
   - `src/agentready/fixers/base.py` - Understand fixer interface
   - `src/agentready/models/fix.py` - Understand fix types

2. **Start with Phase 1 Fixer 1** (README Structure):
   - Create test first
   - Implement fixer
   - Add to FixerService
   - Test manually: `agentready align . --dry-run`

3. **Follow incremental pattern**:
   - One fixer at a time
   - Test after each fixer
   - Commit working code
   - Move to next fixer

4. **Ask questions** when stuck:
   - How should X work?
   - What's the best pattern for Y?
   - Is this implementation correct?

---

**Good luck! Build something awesome. ðŸš€**

---

**Document Version**: 1.0
**Last Updated**: 2025-11-30
**Estimated Time**: 6 weeks
**Difficulty**: Advanced
